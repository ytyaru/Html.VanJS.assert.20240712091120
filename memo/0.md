# 簡易テストツールAssert

　コードの品質を保障するために単体テストしたい。

<!-- more -->

# API

```javascript
const a = new Assertion()
a.t(true)
a.f(false)
a.e(Error, '', ()=>{throw new Error})
```
```javascript
a.t(()=>true)
a.f(()=>false)
a.t(async()=>true)
a.f(async()=>false)
a.e(Error, '', async()=>{throw new Error})
```
```javascript
Assertion.test(
    [a.t, true],
    [a.f, false],
    [a.e, Error, '', ()=>{throw new Error}],
)
```
```javascript
Assertion.test(
    [a.t, true],
    [a.f, false],
    [a.e, Error, '', ()=>{throw new Error}],
)
```
```javascript
Assertion.test({
        method: a.t, // Assertion.t()/f()/e()のいずれか。以降の引数を省略する
    },
    true,
    false,
    ()=>{throw new Error},
)
```
```javascript
Assertion.test({
        method: a.e,
        setup:()=>new TestTarget(),
        tearDown:(t)=>t.close(),
    },
    Error, '', (t)=>{t.throwError()},
    TypeError, 'M', (t)=>{t.throwTypeError('M')},
)
```
```javascript
const a = new Assertion({fileName:'/src/test-target.js'})
a.t(true)
a.t(true)
a.f(false)
a.e(Error,'',()=>throw new Error)
a.fin((count)=>{/*DOM作成処理*/})
```
```javascript
```
```javascript
Assertion.setup({fileName:'/src/test-target.js'})
Assertion.test(...)
Assertion.test(...)
...
// 非同期テスト完了後に引数関数を実行する。Promise.all(...).then((fin)=>fin()/*DOM更新処理*/)する。
Assertion.fin((count)=>{/*DOM更新処理*/}) 
```
```javascript
Assertion.setup({fileName:'/src/test-target.js'})
Assertion.test(...)
Assertion.fin((count)=>{/*DOM更新処理*/}) 
```
```javascript
Assertion.setup({fileName:'/src/test-target.js'})
Assertion.test(...)
Assertion.run((count)=>{/*DOM更新処理*/}) 
```
```javascript
const {setup, test, run } = Assertion
const a = setup({fileName:'/src/test-target.js'})
a.t(true)
a.f(false)
a.e(Error,'',()=>throw new Error)
test(...)
run((count)=>{/*DOM更新処理*/}) 
```


```javascript
Assertion.setup({fileName:'/src/test-target.js'})
Assertion.test(...)
Assertion.fin((count)=>{/*DOM更新処理*/}) 
```







# console.assert

　既存ツールは[`console.assert()`][console.assert]がある。引数値が真なら無視し、偽なら[`console.error()`][console.assert]表示される。

```javascript
console.assert(true)
```
```javascript
console.assert(false)
```

　偽`false`だと以下のようなログがコンソールに出る。（コンソールは開発者ツールにある。Chromeブラウザなら`Ctrl`+`I`キーで開く）

```javascript
Assertion failed: console.assert
```

　テスト内容が判らないので、エラーメッセージを設定する。

```javascript
console.assert(false, 'テストA')
```
```javascript
Assertion failed: テストA
```

　問題は例外発生をテストできないこと。以下のように関数を渡しても何も起こらない。すべてテスト合格の扱いだ。

```javascript
console.assert(()=>true, '関数真')
console.assert(()=>false, '関数偽')
console.assert(()=>{throw new Error()}, '例外が起きること')
```

[console.assert]:https://developer.mozilla.org/ja/docs/Web/API/console/assert_static
[console.error]:https://developer.mozilla.org/ja/docs/Web/API/console/error_static

# 例外発生テストがしたい

　[`console.assert`][console.assert]は例外を含むテストができませんでした。でも、例外発生の有無に関わらずテストしたい。

　まずは例外発生すると成功になるテストがしたい。要件を考えてみる。

* 例外が発生すること
* 例外を殺してテスト合否メッセージを表示すること
* 例外の型が一致すること
* 例外メッセージが一致すること
* 上記条件を満たさない場合はエラーメッセージを出すこと
	* 例外が発生しない旨のエラーメッセージを出す
	* 例外の型が一致しない旨のエラーメッセージを出す
	* 例外のメッセージが一致しない旨のエラーメッセージを出す

　たとえば以下コードで例外発生をテストしたい場合を考えます。定数`v`に値を代入しようとすると`TypeError`が起きます。これはJavaScriptの言語仕様です。

```javascript
const v=0
v=1 // TypeError: Assignment to constant variable.
```

　これをテストするため次のようなインタフェースを考えました。

```javascript
Assert.error(TypeError, 'Assignment to constant variable.', ()=>{const v=0; v=1;})
```

引数|意味
----|----
1|期待するError型
2|期待するError.message値
3|テストコード（無名関数）

　`Assert.error()`の第三引数であるテストコードの内部では`TypeError`が起きます。この関数を`Assert.error()`内部において`try`/`catch`構文で例外を捕まえ殺しています。なので例外発生しません。

　今回は期待値通りの結果になるので、何も起きません。

　次はテストコードをわざと間違えます。例外発生しない正常なコードです。定数`v`に値を代入しません。

```javascript
Assert.error(TypeError, 'Assignment to constant variable.', ()=>{const v=0;})
```

　すると以下のエラーログが表示されます。

```javascript
テスト失敗： 例外発生すべき所で例外発生しませんでした。
```

　今度はわざと期待値をミスしてみましょう。`TypeError`でなく`Error`にします。

```javascript
Assert.error(Error, 'Assignment to constant variable.', ()=>{const v=0;})
```
```javascript
テスト失敗： 例外の型が違います。
期待値：Error
実際値：TypeError
```

　もちろん期待値と実際値を逆にしても同じです。不一致ならエラーログを出します。

```javascript
Assert.error(TypeError, 'Assignment to constant variable.', ()=>{throw new Error()})
```
```javascript
テスト失敗： 例外の型が違います。
期待値：TypeError
実際値：Error
```

　最後にエラーメッセージが一致しない時の確認です。

```javascript
Assert.error(Error, 'A', ()=>{throw new Error('B')})
```
```javascript
テスト失敗： 例外メッセージが違います。
期待値：A
実際値：B
```

　型もメッセージも違う時は両方のメッセージが出ます。

```javascript
Assert.error(Error, 'A', ()=>{throw new TypeError('B')})
```
```javascript
テスト失敗
例外の型が違います。
期待値：Error
実際値：TypeError
例外メッセージが違います。
期待値：A
実際値：B
```

# API

```javascript
Assert.error(Error, 'Assignment to constant variable.', ()=>{const v=0; v=1;})
```
```javascript
Assert.of(options)    // テスト対象（読込リソースのうちテスト対象ファイルを絞り込む文字列（ファイル名等））
Assert.test(options, ...case) // case:assertのt/f/eを引数として渡す, options（setup:()=>, tearDonw:()=>）
Assert.fin()          // テスト完了マーク
```
```javascript
assert.t(真偽値か条件式かそれを返す関数)
assert.f(真偽値か条件式かそれを返す関数)
assert.e(例外型, 例外メッセージ, 例外発生する関数)
```

## 例

```javascript
const a = Assert.of({file:/dir-name\/test-target.js$/, label:'{{fileName}} のテストです'})
Assert.test(
  a.t(true),
  a.f(true),
  a.e(Error,'',()=>{throw new Error}),
)
Assert.test({
	label:'TestTargetクラスのテストです',
    setup:()=>return new TestTarget('A'), // 各所の`o`になる。
    tearDown:(o)=>o.close(),
  },
  (o)=>a.t(o.some(0)),
  (o)=>a.f(o.some(1)),
  (o)=>a.e(Error,'',()=>{o.throw()}),
)
Assert.fin()
```
```javascript
Assert.test({
    setup:async()=>{const r = await Target.gets(); return r;}, // 各所の`o`になる。
    tearDown:async(o)=>await o.close(),
  },
  async(o)=>{const s=await o.some(); return a.t(0===s)},
  async(o)=>{const s=await o.some(); return a.f(1===s)},
  async(o)=>{a.e(Error,'',async()=>{o.throw()})},
)
```

　あらゆる部分をコールバック関数で埋めて`async`したら以下。

```javascript
Assert.test({
    setup:async()=>{const r = await Target.gets(); return r;}, // 各所の`o`になる。
    tearDown:async(o)=>await o.close(),
  },
  async(o)=>{const s=await o.some(); return a.t(async()=>0===s)},
  async(o)=>{const s=await o.some(); return a.f(async()=>1===s)},
  async(o)=>{a.e(Error,'',async()=>{o.throw()})},
)
```

## HTML表示

　テストが全件合格した場合は次のように表示される。

```
test-target.js のテストです。

成功：NNNNN 件
```

　テストに失格が一件以上あった場合は次のように表示される。

```
test-target.js のテストです。

失敗：NNNNN 件
成功：NNNNN 件

詳細は開発者ツールのコンソールをご覧ください。以降のテスト工程は以下です。

1. エラーログを見る
2. スタックトレースを見る
3. エラー箇所をクリックする
4. コードを修正する
5. 本ページをリロードして再テストする
6. エラーがなくなるまで繰り返す
```

　テストコードで例外発生したら次のように表示される。

```
test-target.js のテストです。

テストコードで例外発生しました。テストコードを確認して書き直してください。

詳細は開発者ツールのコンソールをご覧ください。
```












```javascript
window.addEventListener('load', (event) => {
	window.Resources = window.performance.getEntriesByType('resource').map(r=>r.name)
	Object.freeze(Resources)
});
```


```javascript
var resources = window.performance.getEntriesByType('resource');
resources.forEach(function (resource) {
    console.log(resource.name);
});
```

# BlackBoxTest

　メソッドのテスト。引数と戻り値のセットで合否判定する。

```javascript
const a = new Assertion()
a.b.test({
  class: [TestTarget, [引数,引数,...]],
  method: 'someMethod',
  asserts: {
    't': [
      [[引数,...], (r)=>r],
    ],
    'f': [
      [[引数,...], (r)=>r],
    ],
    'e': [
      [[引数,...], Error, 'ErrMsg'],
    ],
    [[], ]
  }
})
```

　`r`にはメソッドの戻り値が入る。`(r)=>r`は`assert.t/f/e()`の引数に渡すテストコード関数または期待する例外型とエラーメッセージ。

　`method`を渡さないとコンストラクタのテストになる。このとき`r`に入るのは`class`で指定したクラスを`new`して返ったインスタンスである。

```javascript
const a = new Assertion()
a.b.test({
  class: TestTarget,
  asserts: [[引数,...], (r)=>r],
})
```

　`b.test()`の引数が配列なら、`class`と`asserts`の略になる。`asserts`は`t/f/e`のうち何も指定せねば第二引数の型によって自動て決定する。

```javascript
const a = new Assertion()
a.b.test([TestTarget, [ // メソッド名がないためコンストラクタのテストであると判断する
  [引数,...], (r)=>r,   // コンストラクタでは例外発生で中断しないはずなので例外テスト不要
  [引数,...], (r)=>r,   // a.t() と判断する（略時a.f()は使用不能。a.t()で代用する）
  [引数,...], (r)=>r,
])
```
```javascript
const a = new Assertion()
a.b.test([[TestTarget,[引数,...]],
 'methodName', [
  [引数,...], (r)=>r,                // a.t() と判断する（略時a.f()は使用不能。a.t()で代用する）
  [引数,...], (r)=>r,                // a.t() と判断する（略時a.f()は使用不能。a.t()で代用する）
  [引数,...], new Error('Message'),  // a.e() と判断する
])
```
```javascript
const a = new Assertion()
a.b.test({
  class: [TestTarget,[引数,...]],
  method: 'methodName', 
  inouts: [
    [引数,...], (r)=>r,                // a.t() と判断する（略時a.f()は使用不能。a.t()で代用する）
    [引数,...], (r)=>r,                // a.t() と判断する（略時a.f()は使用不能。a.t()で代用する）
    [引数,...], Error, 'Message', (r)=>r.throwError(),  // a.e() と判断する
  ],
])
```

　今更気づいたが、エラーの場合、引数を二つにまとめることも可能だった。`new Error('エラー文言')`とすれば型とメッセージをまとめられる。ただ、正常系と違って二つ必要なので正常系と異常系で引数の数を統一できないのは同じ。

```javascript
const a = new Assertion()
a.assert(Boolean)
a.assert(Function)
a.assert(AsyncFunction)
a.assert(Error, Function/AsyncFunction)
```
```javascript
const a = new Assertion()
a.assert(true)
a.assert(()=>true)
a.assert(async()=>true)
a.assert(new Error(''), ()=>{throw new Error('')})
```

　異常系は期待値となる例外の型とメッセージを次の二パターンのうちいずれかで指定できるようにしたい。

```javascript
a.assert(Error, '', ()=>{throw new Error('')})
a.assert(new Error(''), ()=>{throw new Error('')})
```

　メッセージの判定はしたくない場合もありそう。その場合は`undefined`で指定する。空文字だと、空文字が期待値である場合と区別できなくなってしまう。その場合は二つ目の記法のほうがスッキリ書ける。

```javascript
a.assert(Error, undefined, ()=>{throw new Error()})
a.assert(new Error(), ()=>{throw new Error()})
```

　異常系の場合、メッセージ確認するときは前者のほうがシンプルに書ける。

```javascript
a.assert(Error, 'MSG', ()=>{throw new Error('MSG')})
a.assert(new Error('MSG'), ()=>{throw new Error('MSG')})
```

　だが、メッセージ確認せず型確認のみの場合は、後者のほうがシンプルに書ける。

```javascript
a.assert(Error, undefined, ()=>{throw new Error()})
a.assert(new Error(), ()=>{throw new Error()})
```

　つまり正常系、異常系はそれぞれ以下の引数パターンとなる。

```javascript
const a = new Assertion()
正常系
a.assert(Boolean)
a.assert(Function)
a.assert(AsyncFunction)
異常系
a.assert(ErrorConstructor, String, Function/AsyncFunction)
a.assert(Error, Function/AsyncFunction)
```

　それはつまり、第一引数の型によって正常系／異常系を振り分けることが可能であることを意味する。

　ならばAPIはシンプルになりそうだ。その場合、正常系は真偽値を返すことになり、真ならばテスト成功と判断する。

```javascript
const a = new Assertion()
正常系
a.assert(true)
a.assert(()=>true)
a.assert(async()=>true)
異常系
a.assert(Error, 'Msg', ()=>{throw new Error('Msg')})
a.assert(Error, 'Msg', async()=>{throw new Error('Msg')})
a.assert(new Error('Msg'), ()=>{throw new Error('Msg')})
a.assert(new Error('Msg'), async()=>{throw new Error('Msg')})
```



```javascript
assert(...args) {
    if (1===args.length) { // 正常系
        if (isAFn(args[0]))  // 
        if (isFn(args[0]))   // 
        if (isBool(args[0])) // 
        if (isObj(args[0]))  // BlackBoxテスト
        throw new Error()    // テスト例外。正常系テストの引数は真偽値かそれを返す関数であるべきです。またはブラックボックステスト用オブジェクトも受け付けます。
    } else if (2 <= args.length) { // 異常系
        if (isErrorConstructor(args[0]) && isString(args[1]) && (isFn(args[2]) || sisAFn(args[2])))
        if (isError(args[0]) && (isFn(args[1]) || isAFn(args[1])))
        throw new Error()  // テスト例外。異常系テストの引数は期待する例外オブジェクトとそれを発生させる関数であるべきです
    }
    throw new Error()  // テスト例外。テストの引数は正常系なら真偽値かそれを返す関数、異常系なら期待する例外オブジェクトとそれを発生させる関数であるべきです
}
```

```javascript
const a = new Assertion()
a.t(true)
a.f(false)
a.e(Error, undefined, ()=>{throw new Error()})
a.e(new Error(), ()=>{throw new Error()})

a.t(()=>true)
a.f(()=>false)

a.t(async()=>true)
a.f(async()=>false)
a.e(Error, undefined, async()=>{throw new Error()})
a.e(new Error(), async()=>{throw new Error()})

a.b.test(TestTarget, (r)=>r instanceof TestTarget)
a.b.test(TestTarget, [
  [[args], (r)=>r instanceof TestTarget],
  ...
])
a.b.test(TestTarget, 
  'methodName',
  [
    [[args], (r)=>r instanceof TestTarget],
    ...
])
a.b.test([TestTarget, [args]],
  'methodName',
  [
    [[args], (r)=>r instanceof TestTarget],
    ...
])

a.b.test(TestTarget, async(r)=>r instanceof TestTarget)

a.b.test(TestTarget, Error, 'msg')
a.b.test(TestTarget, new Error('msg'))
a.b.test(TestTarget, [
  [[args], Error, 'msg'],
  [[args], new Error('msg')],
  ...
])
a.b.test(TestTarget, 
  'methodName', [
    [[], Error, 'msg'],
    [[], new Error('msg')],
    ...
])
a.b.test([TestTarget, [args]], 
  'methodName',
  [
    [[args], Error, 'msg'],
    [[args], new Error('msg')],
  ...
])

a.b.test(()=>new TestTarget(args), 
  'methodName',
  [
    [[args], Error, 'msg'],
    [[args], new Error('msg')],
  ...
])



a.a(true)
a.a(false)
a.a(Error, undefined, ()=>{throw new Error()})
a.a(new Error(), ()=>{throw new Error()})
a.b(class, method, asserts, tearDown)
```

BlackBoxTest

* テスト対象オブジェクト（往々にして某クラスのインスタンス）
* テスト対象関数（往々にして某クラスのメソッド。またはコンストラクタ関数）
* アサート内容（往々にしてテスト対象関数の引数と、その引数を受ける真偽値を返す無名関数）

```javascript
{
  class: {
    new/constructor: TestTarget,
    args: [引数, 引数, ...],
    del/deconstructor: (t)=>t.close(),
  },
  method: {
    fn: '関数名'/(ins)=>ins.テスト対象関数,
  },
  asserts: [
    [[引数, 引数, ...], (r)=>r],
    [[引数, 引数, ...], Error, 'msg'],
    [[引数, 引数, ...], new Error('msg')],
  ]
}
```

```javascript
{
  target: {
    new: ()=>(new TestTarget(引数)).testMethod,
    del: (t)=>t.close(),
  },
  asserts: [
    [[引数, 引数, ...], (r)=>r],
    [[引数, 引数, ...], Error, 'msg'],
    [[引数, 引数, ...], new Error('msg')],
  ]
}
```

　テスト対象は次のいずれか。

* コンストラクタ関数（new Constructor()）
* コンストラクタ関数がもつ関数（staticメソッド）
* インスタンスメソッド

　ゲッター／セッターに関してテストするときは、テスト対象をコンストラクタ関数にし、アサート内容に書く。

```javascript
{
  target: {
    new: ()=>Human
    del: (t)=>t.close(),
  },
  asserts: [
    [['山田'], (t)=>t.name==='山田'], // getter
    [['山田'], (t)=>{
      t.name = '鈴木'        // setter
      return t.name==='鈴木'
    }],
  ]
}
```

```javascript
{
  target: {
    new: ()=>Human                          // コンストラクタ関数をasserts対象とする
    new: ()=>new Human()                    // このインスタンスをasserts対象とする
    new: ()=>new Human('山田')              // このインスタンスをasserts対象とする
    new: ()=>(new Human('山田')).someMethod   // このインスタンスのメソッドをasserts対象とする
  },
}
```

　ただ、インスタンスのメソッドを指定されたとき、レシーバの`new Human('山田')`インスタンスを取得できるかどうか。


```javascript
class Human { constructor(n){this.n=n;} m(){return this.n;} }
const m = (new Human('山田')).m
console.assert(m()==='山田') // TypeError: Cannot read property 'n' of undefined
```

```javascript
class Human { constructor(n){this.n=n;} m(){return this.n;} }
const h= new Human('山田')
const m = h.m.bind(h)
console.assert(m()==='山田') // OK
```

　ダメだった。メソッドからその所属元インスタンスを取得することができない。ので、クラスとメソッドは分離すべき。

```javascript
{
  target: {
    new: ()=>Human,
    getter: (t)=>t.name,
    del: (t)=>t.close(),
  },
  asserts: [
    [['山田'], (r)=>r==='山田'], // getter
    [['鈴木'], (r)=>r==='鈴木'], // getter
  ]
}
```
```javascript
{
  target: {
    new: ()=>new Human('山田'),
    setter: (t)=>t.name,
    del: (t)=>t.close(),
  },
  asserts: [
    ['鈴木', (t)=>t.name==='鈴木'], // getter
  ]
}
```

　`getter`の場合、引数がないので`asserts`の引数はコンストラクタのものだと判る。だが、`setter`の場合は代入値を引数として設定する必要がある。このとき、`new`にはコンストラクタでなくインスタンスを渡すべき。さもなくば`asserts`の引数を`setter`に渡せない。なお、`setter`のとき引数は配列の必要がない。`setter`は可変長引数を取らないから。ただし配列を代入させたいときは配列をセットすればそのまま配列が代入される。

```javascript
{
  target: {
    new: ()=>Human,         // 必須
    method: (t)=>t.method,  // 任意（method, getter, setterは一つもないか一つだけのみ許容する。複数はダメ）
    getter: (t)=>t.name,
    setter: (t)=>t.name,
    del: (t)=>t.close(),    // 任意
  },
  asserts: [
    ['鈴木', (t)=>t.name==='鈴木'], // getter
  ]
}
```

　`delete obj.key`のテストとして`target.del`を用意したかった。これは`getter`,`setter`と揃えたかった。そうなるとでコンストラクタ／ファイナライザである`del`と名前重複する。そこで旧`del`を`finally`に改名する。

```javascript
{
  target: {
    new: ()=>Human,         // 必須
    method: (t)=>t.method,  // 任意（method, getter, setter, deleterは一つもないか一つだけのみ許容する。複数はダメ）
    getter: (t)=>t.name,
    setter: (t)=>t.name,
    deleter: (t)=>t.name,
    finally: (t)=>t.close(), // 任意
  },
  asserts: [
    ['鈴木', (t)=>t.name==='鈴木'], // getter
  ]
}
```

　`new`は最初にインスタンス生成する。これに対して`finally`は最後に終了処理として実行する。生成に対する破壊として`destroy`でもいい。あるいには`finally`に対して`new`でなく`initialize`でもいい。できるだけ短く書けて、覚えやすく、意味が理解できる語がいい。`finally`は`try,catch,finally`句にも存在するため採用した。よくあるテスト体系は`setup()`,`tearDonw()`だが、今回はテスト対象とその引数・結果パターンだけを変化させたい。よってさらに粒度の細かい語を使うことにした。

　なるだけJavaScriptの用語と一致させることで誤解なくテストできるはず。

　そうなると、`new`が怪しい。場合によってはコンストラクタを渡してコンストラクタや`static`メソッドのテストもしたいからだ。つまり、以下のように構造化するのが正しい

```javascript
a.b.test({
  target: {
    object: { // newかconstructorのいずれか一つのみ（必須）
      new: new Human(),
      constructor: Human,
    },
    function: { // 一つもないか以下のうちいずれか一つのみ（任意）
      method: 'staticMethod'
      getter: 'name',
      setter: 'name',
      deleter: 'name',
    },
  }, 
  asserts: [
    [[args], (r)=>r===100],
    [[args], Error, 'msg'],
    [[args], new Error('msg')],
  ...
])
```

```javascript
asserts: [
  (r)=>r===100,              // getter 正常系（deleteもこれだがgetterと区別がつかないためdelete時はキー明記必須）
  new Error('msg'),          // getter 異常系（deleteもこれだがgetterと区別がつかないためdelete時はキー明記必須）
  [101, (t)=>t.v===101],     // setter 正常系
  [101, new Error('msg')],   // setter 異常系
  [[1,2], (r)=>r===1],       // method 正常系
  [[1,2], new Error('msg')], // method 異常系
]
```


```javascript
{
    cls: コンストラクタ/インスタンス,             // 必須
    clsArgs: 配列（可変長引数）,                  // 任意
    method/getter/setter/delete: 'テスト対象名',  // 任意
    asserts: [                                    // 必須
        // 以下6パターン（method/getter/setter/deleteのいずれかと、正常系／異常系か、の組合せ次第）
        (r)=>r,
        new Error('msg'),
        ['v', (t)=>t.v==='v'],
        ['v', new Error('msg')],
        [[args], (r)=>r],
        [[args], new Error('msg')],
    ]
}
```
```javascript
a.b.test({
  sender/target: Human / new Human(),
  method/getter/setter/deleter: '名前',
  asserts: [
    [[args], (r)=>r===100],
    [[args], Error, 'msg'],
    [[args], new Error('msg')],
  ...
])
```
```javascript
Reflect.constructor()
Reflect.get()
Reflect.set()
Reflect.delete()
Reflect.constructor()
Reflect.call()
```

　できれば`method/getter/setter`はわざわざ指定せずとも`method`を共用したかった。`Object.getOwnPropertyDescriptors()`でゲッターかセッターかを判断したかった。でもよく考えると、次のようなパターンは区別できない。

* ゲッター・セッター共になし（フィールドかメソッドである）
* ゲッターのみある
* セッターのみある
* ゲッターとセッターの両方ある（どちらをテストするか判断できない（`assearts`の引数の有無では判断できない。`target.constructor`だった場合はコンストラクタの引数として設定されていると仮定すれば引数不要の`getter`テストだと判断できるかもしれない。`target.new`だった場合は`setter`と判断し、））
* `deleter`はそもそもディスクリプタに存在しない（`delete`をフックする仕組みは`Proxy`しかない）

　なので仕方なく`method/getter/setter/deleter`の4種をその名前にて区別する。これにより以下コードのどれを実行すべきか分岐する。

```javascript
Reflect.get()       // getter実行
Reflect.set()       // setter実行
Reflect.delete()    // delete文実行
Reflect.call()      // メソッド実行
Reflect.construct() // コンストラクタ実行
```
```javascript
{
  target /tar/t: Human/new Human('山田'), // 必須
  method /met/m: 'someMethod',            // 任意（m,g,s,dは一つもないか一つだけのみ許容する。複数はダメ）
  getter /get/g: 'someName',
  setter /set/s: 'someName',
  delete /del/d: 'someName',
  finally/fin/f: (t)=>t.close(),
  asserts/ass/a: [
    metArgs, assArgs
  ]
}
```

```javascript
[target, (m/g/s/d), (f), asserts]
{
  target /tar/t: Human/new Human('山田'), // 必須
  method /met/m: 'someMethod',            // 任意（m,g,s,dは一つもないか一つだけのみ許容する。複数はダメ）
  getter /get/g: 'someName',
  setter /set/s: 'someName',
  delete /del/d: 'someName',
  finally/fin/f: (t)=>t.close(),          // 任意
  asserts/ass/a: [                        // 必須
    metArgs, assArgs
  ]
}
```

```javascript
[c, (m/g/s/d), (f), a]
{
  class  /cls/c: Human/new Human('山田'), // 必須
  method /met/m: 'someMethod',            // 任意（m,g,s,dは一つもないか一つだけのみ許容する。複数はダメ）
  getter /get/g: 'someName',
  setter /set/s: 'someName',
  delete /del/d: 'someName',
  finally/fin/f: (t)=>t.close(),          // 任意
  asserts/ass/a: [                        // 必須
    metArgs, assArgs
  ]
}
```

class C {
  get G() {return 0}
}
Object.getOwnPropertyDescriptors(C)
Object.getOwnPropertyDescriptors(new C)
Object.entries(new C)
c.__lookupGetter__('G')

c.__lookupGetter__('G')



　`target`は以下のように短縮できる。

```javascript
{
  target: {
    new: ()=>Human,      // 必須
    met: (t)=>t.method,  // 任意（method, getter, setterは一つもないか一つだけのみ許容する。複数はダメ）
    get: (t)=>t.name,
    set: (t)=>t.name,
    del: (t)=>t.close(), // 任意
  },
}
```
```javascript
{
  target: {
    n: ()=>Human,      // 必須
    m: (t)=>t.method,  // 任意（method, getter, setterは一つもないか一つだけのみ許容する。複数はダメ）
    g: (t)=>t.name,
    s: (t)=>t.name,
    d: (t)=>t.close(), // 任意
  },
}
```
```javascript
[constructor]
[constructor, method]
[constructor, deleter]
[constructor, method, deleter]
```
```javascript
[con/ins]
[con/ins, met/get/set]
[con/ins, deleter]
[con/ins, method, deleter]
```

